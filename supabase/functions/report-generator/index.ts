import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import OpenAI from "https://esm.sh/openai@4";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface ReportJob {
  id: number;
  scan_id: string;
  report_type: 'threat_snapshot' | 'executive_summary' | 'technical_remediation';
  status: string;
}

interface ReportTemplate {
  system_prompt: string;
  user_prompt_template: string;
  max_output_tokens: number;
  estimated_cost_usd: number;
}

interface ScanData {
  scan_id: string;
  company_name: string;
  domain: string;
  scan_date: string;
  critical_count: number;
  high_count: number;
  medium_count: number;
  low_count: number;
  info_count: number;
  eal_low_total: number;
  eal_ml_total: number;
  eal_high_total: number;
  eal_daily_total: number;
  findings_data: any[];
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Initialize Supabase client with service role
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY')!;

    const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);
    const openai = new OpenAI({ apiKey: openaiApiKey });

    // Get pending report jobs
    const { data: pendingJobs, error: jobsError } = await supabase
      .from('report_jobs')
      .select('*')
      .eq('status', 'pending')
      .order('created_at', { ascending: true })
      .limit(3); // Process up to 3 jobs per invocation (reduced for rate limiting)

    if (jobsError) {
      console.error('Error fetching report jobs:', jobsError);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch report jobs' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!pendingJobs || pendingJobs.length === 0) {
      return new Response(
        JSON.stringify({ message: 'No pending report jobs' }),
        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const results = [];

    // Process each job
    for (const job of pendingJobs as ReportJob[]) {
      try {
        console.log(`Processing report job ${job.id} for scan ${job.scan_id}`);

        // Mark job as processing
        await supabase
          .from('report_jobs')
          .update({ 
            status: 'processing', 
            started_at: new Date().toISOString() 
          })
          .eq('id', job.id);

        // Get report template
        const { data: template, error: templateError } = await supabase
          .from('report_templates')
          .select('*')
          .eq('report_type', job.report_type)
          .single();

        if (templateError || !template) {
          throw new Error(`Failed to fetch template for ${job.report_type}: ${templateError?.message}`);
        }

        // Get scan data
        const { data: scanData, error: scanError } = await supabase
          .from('report_scan_data')
          .select('*')
          .eq('scan_id', job.scan_id)
          .single();

        if (scanError || !scanData) {
          throw new Error(`Failed to fetch scan data for ${job.scan_id}: ${scanError?.message}`);
        }

        // Build the prompt
        const prompt = buildPrompt(template as ReportTemplate, scanData as ScanData);

        // Generate report with OpenAI
        console.log(`Calling OpenAI for report type: ${job.report_type}`);
        const completion = await openai.chat.completions.create({
          model: 'gpt-4o-mini-2024-07-18', // Using o1-mini for now since o3 might not be available
          messages: [
            { role: 'system', content: template.system_prompt },
            { role: 'user', content: prompt }
          ],
          max_tokens: template.max_output_tokens,
          temperature: 0.1,
        });

        const markdownContent = completion.choices[0]?.message?.content;
        if (!markdownContent) {
          throw new Error('No content generated by OpenAI');
        }

        // Calculate costs
        const tokensInput = completion.usage?.prompt_tokens || 0;
        const tokensOutput = completion.usage?.completion_tokens || 0;
        const costUsd = (tokensInput * 0.000002) + (tokensOutput * 0.000008); // o1-mini pricing

        // Store the report in Supabase Storage
        const storagePath = `reports/${job.scan_id}/${job.report_type}.md`;
        const { error: storageError } = await supabase.storage
          .from('reports')
          .upload(storagePath, new Blob([markdownContent], { type: 'text/markdown' }), {
            upsert: true
          });

        if (storageError) {
          console.error('Storage error:', storageError);
          // Continue processing - we can still save to database
        }

        // Update job with results
        await supabase
          .from('report_jobs')
          .update({
            status: 'completed',
            completed_at: new Date().toISOString(),
            markdown_content: markdownContent,
            storage_path: storagePath,
            tokens_input: tokensInput,
            tokens_output: tokensOutput,
            cost_usd: costUsd,
          })
          .eq('id', job.id);

        console.log(`Completed report job ${job.id} - Cost: $${costUsd.toFixed(6)}`);
        results.push({
          job_id: job.id,
          status: 'completed',
          tokens_input: tokensInput,
          tokens_output: tokensOutput,
          cost_usd: costUsd
        });

      } catch (error) {
        console.error(`Error processing job ${job.id}:`, error);
        
        // Mark job as failed
        await supabase
          .from('report_jobs')
          .update({
            status: 'failed',
            completed_at: new Date().toISOString(),
            error_message: error.message,
          })
          .eq('id', job.id);

        results.push({
          job_id: job.id,
          status: 'failed',
          error: error.message
        });
      }
    }

    return new Response(
      JSON.stringify({ 
        message: `Processed ${results.length} report jobs`,
        results 
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );

  } catch (error) {
    console.error('Edge function error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error', details: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

function buildPrompt(template: ReportTemplate, scanData: ScanData): string {
  // Extract variables from scan data
  const variables = {
    scan_data: JSON.stringify(scanData.findings_data, null, 2),
    risk_totals: JSON.stringify({
      eal_low: scanData.eal_low_total,
      eal_ml: scanData.eal_ml_total,
      eal_high: scanData.eal_high_total,
      eal_daily: scanData.eal_daily_total,
    }, null, 2),
    company_name: scanData.company_name,
    domain: scanData.domain,
    scan_date: new Date(scanData.scan_date).toLocaleDateString(),
    
    // For executive summary and technical reports
    risk_calculations: JSON.stringify({
      total_findings: scanData.critical_count + scanData.high_count + scanData.medium_count + scanData.low_count,
      critical_count: scanData.critical_count,
      high_count: scanData.high_count,
      medium_count: scanData.medium_count,
      low_count: scanData.low_count,
      eal_totals: {
        low: scanData.eal_low_total,
        ml: scanData.eal_ml_total,
        high: scanData.eal_high_total,
        daily: scanData.eal_daily_total
      }
    }, null, 2),
    
    company_profile: `${scanData.company_name} (${scanData.domain})`,
    threat_landscape: 'External threat landscape data would go here', // TODO: Add real threat intel
    historical_data: '', // TODO: Add historical scan comparison
    
    // For technical reports
    detailed_findings: JSON.stringify(scanData.findings_data.filter(f => 
      ['CRITICAL', 'HIGH', 'MEDIUM'].includes(f.severity)
    ), null, 2),
    scan_artifacts: JSON.stringify(scanData.findings_data.map(f => ({
      type: f.artifact_type,
      value: f.artifact_value,
      meta: f.meta
    })), null, 2),
    system_configurations: 'System configuration data would go here', // TODO: Extract from scan artifacts
    threat_intelligence: 'Threat intelligence data would go here', // TODO: Add threat intel
    
    // NEW: AI-generated remediation guidance
    remediation_guidance: JSON.stringify(scanData.findings_data
      .filter(f => f.remediation && ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].includes(f.severity))
      .map(f => ({
        finding: f.finding_description,
        severity: f.severity,
        cve_id: f.meta?.cve_id,
        remediation: f.remediation
      })), null, 2),
    
    findings_with_remediation: JSON.stringify(scanData.findings_data
      .filter(f => f.remediation)
      .map(f => ({
        type: f.finding_type,
        description: f.finding_description,
        severity: f.severity,
        target: f.artifact_value,
        cve_details: {
          cve_id: f.meta?.cve_id,
          cvss_score: f.meta?.cvss_score || f.meta?.cvss_base,
          epss_score: f.meta?.epss,
          verified: f.meta?.verified_cve,
          exploitable: f.meta?.exploitable
        },
        remediation: f.remediation
      })), null, 2)
  };

  // Replace template variables
  let prompt = template.user_prompt_template;
  for (const [key, value] of Object.entries(variables)) {
    prompt = prompt.replace(new RegExp(`\\{${key}\\}`, 'g'), value);
  }

  return prompt;
}

/* Edge Functions Region Configuration:
 * This function should be deployed to the us-west-1 region (SEA)
 * to match the Fly.io deployment region for optimal performance.
 * 
 * To deploy:
 * supabase functions deploy report-generator --region=us-west-1
 */