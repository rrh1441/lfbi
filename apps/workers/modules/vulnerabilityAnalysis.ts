/* =============================================================================
 * MODULE: vulnerabilityAnalysis.ts
 * =============================================================================
 * Vulnerability analysis and processing for technology stacks.
 * Handles OSV.dev, GitHub Security Advisories, CVE validation, EPSS scoring,
 * and active testing with Nuclei.
 * =============================================================================
 */

import axios from 'axios';
import semver from 'semver';
import { runNuclei as runNucleiWrapper } from '../util/nucleiWrapper.js';
import { log as rootLog } from '../core/logger.js';
import { UnifiedCache } from './techCache/index.js';
import type { CacheKey } from './techCache/index.js';
import type { WappTech } from './techDetection/index.js';
import { detectEcosystem } from './techDetection/index.js';

const log = (...m: unknown[]) => rootLog('[vulnerabilityAnalysis]', ...m);

// Configuration
const CONFIG = {
  API_TIMEOUT_MS: 15_000,
  EPSS_BATCH: 100,
  MAX_RISK_VULN_AGE_YEARS: 5,
  DROP_VULN_AGE_YEARS: 5,
  DROP_VULN_EPSS_CUT: 0.05,
  GITHUB_BATCH_SIZE: 25,
  GITHUB_BATCH_DELAY: 1_000,
} as const;

// Types
export interface VulnRecord {
  id: string;
  source: 'OSV' | 'GITHUB';
  cvss?: number;
  epss?: number;
  cisaKev?: boolean;
  summary?: string;
  publishedDate?: Date;
  affectedVersionRange?: string;
  // Active testing fields
  activelyTested?: boolean;
  exploitable?: boolean;
  verificationDetails?: any;
}

export interface NucleiCVEResult {
  cveId: string;
  templateId: string;
  verified: boolean;
  exploitable: boolean;
  details?: any;
}

export interface EnhancedSecAnalysis {
  eol: boolean;
  vulns: VulnRecord[];
  risk: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  advice: string[];
  versionAccuracy?: number;
  supplyChainScore: number;
  packageIntelligence?: PackageIntelligence;
  activeVerification?: {
    tested: number;
    exploitable: number;
    notExploitable: number;
  };
  cveIds?: string[];  // CVE IDs for external nuclei consolidation
}

export interface PackageIntelligence {
  popularity?: number;
  maintenance?: string;
  license?: string;
  licenseRisk?: 'LOW' | 'MEDIUM' | 'HIGH';
  openSSFScore?: number;
  dependents?: number;
}

export interface VulnerabilityAnalysisConfig {
  cache: UnifiedCache;
  githubToken?: string;
  apiTimeout?: number;
  enableActiveVerification?: boolean;
  enableEOLCheck?: boolean;
}

// KEV list cached globally
let kevList: Set<string> | null = null;

export class VulnerabilityAnalysis {
  constructor(private config: VulnerabilityAnalysisConfig) {}

  /* Get CISA Known Exploited Vulnerabilities list */
  async getKEVList(): Promise<Set<string>> {
    if (kevList) return kevList;
    try {
      const { data } = await axios.get(
        'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
        { timeout: this.config.apiTimeout || CONFIG.API_TIMEOUT_MS }
      );
      kevList = new Set<string>(data.vulnerabilities?.map((v: any) => v.cveID) ?? []);
    } catch {
      kevList = new Set();
    }
    return kevList;
  }

  /* Get EPSS scores for CVE IDs */
  async getEPSSScores(cveIds: string[]): Promise<Map<string, number>> {
    if (!cveIds.length) return new Map();
    
    const cacheKey: CacheKey = { type: 'epss', cveId: cveIds.join(',') };
    const cached = await this.config.cache.get<Map<string, number>>(cacheKey);
    if (cached !== null) return cached;

    const epssMap = new Map<string, number>();
    
    try {
      // Process in batches of 100 (EPSS API limit)
      for (let i = 0; i < cveIds.length; i += CONFIG.EPSS_BATCH) {
        const batch = cveIds.slice(i, i + CONFIG.EPSS_BATCH);
        const params = new URLSearchParams();
        batch.forEach(cve => params.append('cve', cve));
        
        const { data } = await axios.get(`https://api.first.org/data/v1/epss?${params}`, {
          timeout: this.config.apiTimeout || CONFIG.API_TIMEOUT_MS
        });
        
        data.data?.forEach((item: any) => {
          epssMap.set(item.cve, parseFloat(item.epss));
        });
        
        // Rate limiting between batches
        if (i + CONFIG.EPSS_BATCH < cveIds.length) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }
      
      await this.config.cache.set(cacheKey, epssMap);
    } catch (error) {
      log(`epss=error error="${(error as Error).message}"`);
    }
    
    return epssMap;
  }

  /* Calculate supply chain risk score */
  supplyChainScore(vulns: VulnRecord[]): number {
    if (!vulns.length) return 0;
    
    const weights = {
      kev: 3.0,
      critical: 2.5,
      high: 2.0,
      medium: 1.0,
      epss_high: 1.5,
      age_recent: 1.2
    };
    
    let score = 0;
    const now = Date.now();
    
    for (const v of vulns) {
      if (v.cisaKev) score += weights.kev;
      
      const cvss = v.cvss || 0;
      if (cvss >= 9) score += weights.critical;
      else if (cvss >= 7) score += weights.high;
      else if (cvss >= 4) score += weights.medium;
      
      if ((v.epss || 0) >= 0.5) score += weights.epss_high;
      
      if (v.publishedDate) {
        const ageMonths = (now - v.publishedDate.getTime()) / (1000 * 60 * 60 * 24 * 30);
        if (ageMonths <= 6) score += weights.age_recent;
      }
    }
    
    return Math.min(score, 10);
  }

  /* Check if technology version is End-of-Life */
  async isEol(slug: string, version?: string): Promise<boolean> {
    if (!version) return false;
    
    const cacheKey: CacheKey = { type: 'eol', slug, major: version };
    const cached = await this.config.cache.get<boolean>(cacheKey);
    if (cached !== null) return cached;

    try {
      const { data } = await axios.get(`https://endoflife.date/api/${slug}.json`, {
        timeout: this.config.apiTimeout || CONFIG.API_TIMEOUT_MS
      });
      
      const eol = data.some((rel: any) => {
        if (rel.cycle === version || rel.latest === version) {
          return rel.eol === true || (typeof rel.eol === 'string' && new Date(rel.eol) < new Date());
        }
        return false;
      });
      
      await this.config.cache.set(cacheKey, eol);
      return eol;
    } catch {
      await this.config.cache.set(cacheKey, false);
      return false;
    }
  }

  /* Version range checking */
  isVersionInRange(version: string, range: string): boolean {
    try {
      if (range.includes('>=') && range.includes('<')) {
        const [lower, upper] = range.split(',').map(s => s.trim());
        const lowerVer = lower.replace(/[><=]/g, '').trim();
        const upperVer = upper.replace(/[><=]/g, '').trim();
        return semver.gte(version, lowerVer) && semver.lt(version, upperVer);
      }
      if (range.startsWith('>=')) {
        return semver.gte(version, range.replace('>=', '').trim());
      }
      if (range.startsWith('<')) {
        return semver.lt(version, range.replace('<', '').trim());
      }
      return range === version;
    } catch {
      return false;
    }
  }

  /* CVE timeline validation */
  validateCVETimeline(cveId: string, publishedDate?: Date, softwareVersion?: string): boolean {
    if (!cveId.startsWith('CVE-')) return true;
    
    try {
      const yearMatch = cveId.match(/CVE-(\d{4})/);
      if (!yearMatch) return true;
      
      const cveYear = parseInt(yearMatch[1]);
      const currentYear = new Date().getFullYear();
      
      // Drop very old CVEs unless they're recent enough to be relevant
      if (currentYear - cveYear > CONFIG.DROP_VULN_AGE_YEARS) {
        return false;
      }
      
      // If we have software version, check if CVE could affect it
      if (softwareVersion) {
        const estimatedReleaseYear = this.estimateVersionReleaseYear(softwareVersion);
        if (estimatedReleaseYear && cveYear < estimatedReleaseYear - 2) {
          return false; // CVE too old to affect this version
        }
      }
      
      return true;
    } catch {
      return true; // Default to including if parsing fails
    }
  }

  /* Estimate software version release year */
  estimateVersionReleaseYear(version: string): number | null {
    try {
      // Try to extract year from version string (e.g., 2022.1.0, v23.4)
      const yearMatch = version.match(/20(\d{2})|19(\d{2})/);
      if (yearMatch) {
        const year = parseInt(yearMatch[0]);
        if (year >= 1990 && year <= new Date().getFullYear()) {
          return year;
        }
      }
      
      // Use major version as rough estimate (very rough heuristic)
      const majorMatch = version.match(/^(\d+)/);
      if (majorMatch) {
        const major = parseInt(majorMatch[1]);
        if (major > 0 && major < 100) {
          // Very rough estimate: assume major version releases every 1-2 years
          return Math.max(2000, new Date().getFullYear() - major);
        }
      }
      
      return null;
    } catch {
      return null;
    }
  }

  /* OSV.dev vulnerability lookup */
  async getOSVVulns(t: WappTech): Promise<VulnRecord[]> {
    if (!t.version) return [];
    
    const ecosystem = detectEcosystem(t);
    if (!ecosystem) return [];

    const cacheKey: CacheKey = { type: 'osv', ecosystem, package: t.slug, version: t.version };
    const cached = await this.config.cache.get<VulnRecord[]>(cacheKey);
    if (cached !== null) return cached;

    try {
      const { data } = await axios.post('https://api.osv.dev/v1/query', {
        version: t.version,
        package: { name: t.slug, ecosystem }
      }, { timeout: this.config.apiTimeout || CONFIG.API_TIMEOUT_MS });

      const vulns: VulnRecord[] = (data.vulns || [])
        .filter((v: any) => {
          // First check if it affects this version
          const affects = v.affected?.some((a: any) => {
            const pkg = a.package;
            if (pkg?.ecosystem !== ecosystem || pkg?.name !== t.slug) return false;
            
            // Check version ranges
            return a.ranges?.some((r: any) => {
              if (r.type === 'SEMVER') {
                return r.events?.some((e: any, i: number) => {
                  if (e.introduced === '0' && i + 1 < r.events.length) {
                    const nextEvent = r.events[i + 1];
                    if (nextEvent.fixed) {
                      return semver.lt(t.version!, nextEvent.fixed);
                    }
                  }
                  return false;
                });
              }
              return false;
            });
          });

          if (!affects) return false;

          // Then validate CVE timeline
          if (v.id.startsWith('CVE-')) {
            const publishedDate = v.published ? new Date(v.published) : undefined;
            return this.validateCVETimeline(v.id, publishedDate, t.version);
          }
          
          return true;
        })
        .map((v: any) => ({
          id: v.id,
          source: 'OSV' as const,
          cvss: v.database_specific?.cvss_score || this.extractCVSSFromSeverity(v.severity),
          summary: v.summary,
          publishedDate: v.published ? new Date(v.published) : undefined,
          affectedVersionRange: v.affected?.[0]?.ranges?.[0]?.events?.map((e: any) => 
            e.introduced ? `>=${e.introduced}` : e.fixed ? `<${e.fixed}` : ''
          ).filter(Boolean).join(', ')
        }));

      await this.config.cache.set(cacheKey, vulns);
      return vulns;
    } catch (error) {
      log(`osv=error tech="${t.slug}" error="${(error as Error).message}"`);
      await this.config.cache.set(cacheKey, []);
      return [];
    }
  }

  /* GitHub Security Advisory lookup */
  async getGitHubVulns(t: WappTech): Promise<VulnRecord[]> {
    const ecosystem = detectEcosystem(t);
    if (!ecosystem || !t.version) return [];
    
    const cacheKey: CacheKey = { type: 'github', ecosystem, package: t.slug, version: t.version };
    const cached = await this.config.cache.get<VulnRecord[]>(cacheKey);
    if (cached !== null) return cached;

    const token = this.config.githubToken || process.env.GITHUB_TOKEN;
    if (!token) return [];

    try {
      const query = `
        query($ecosystem: SecurityAdvisoryEcosystem!, $package: String!) {
          securityVulnerabilities(first: 20, ecosystem: $ecosystem, package: $package) {
            nodes {
              advisory {
                ghsaId
                summary
                severity
                cvss {
                  score
                }
              }
              vulnerableVersionRange
            }
          }
        }
      `;

      const { data } = await axios.post('https://api.github.com/graphql', {
        query,
        variables: {
          ecosystem: this.mapEcosystemToGitHub(ecosystem),
          package: t.slug
        }
      }, {
        headers: { Authorization: `Bearer ${token}` },
        timeout: this.config.apiTimeout || CONFIG.API_TIMEOUT_MS
      });

      const vulns: VulnRecord[] = (data.data?.securityVulnerabilities?.nodes || [])
        .filter((node: any) => {
          // First check if version is in vulnerable range
          if (!this.isVersionInRange(t.version!, node.vulnerableVersionRange)) {
            return false;
          }
          
          // Then validate CVE timeline for CVE-based advisories
          const cveMatch = node.advisory.ghsaId.match(/CVE-\d{4}-\d+/);
          if (cveMatch) {
            return this.validateCVETimeline(cveMatch[0], undefined, t.version);
          }
          
          return true;
        })
        .map((node: any) => ({
          id: node.advisory.ghsaId,
          source: 'GITHUB' as const,
          cvss: node.advisory.cvss?.score,
          summary: node.advisory.summary,
          affectedVersionRange: node.vulnerableVersionRange
        }));

      await this.config.cache.set(cacheKey, vulns);
      return vulns;
    } catch {
      await this.config.cache.set(cacheKey, []);
      return [];
    }
  }

  /* Active Nuclei CVE testing */
  async runNucleiCVETests(
    target: string, 
    cveIds: string[], 
    technology?: string
  ): Promise<Map<string, NucleiCVEResult>> {
    const results = new Map<string, NucleiCVEResult>();
    
    if (!cveIds.length) return results;
    
    try {
      // Build templates path for CVE-specific templates
      const cveTemplates = cveIds.map(cve => `cves/${cve.toLowerCase()}.yaml`);
      
      // Run Nuclei with CVE templates using enhanced wrapper
      const nucleiResult = await runNucleiWrapper({
        url: target,
        templates: cveTemplates,
        tags: [], // No tags when using specific templates
        timeout: 30000, // 30s timeout for CVE verification
        concurrency: 5,
        rateLimit: 10
      });
      
      if (nucleiResult.success && nucleiResult.results) {
        // Process findings to extract CVE verification results
        for (const finding of nucleiResult.results) {
          // Extract CVE ID from template or finding
          const cveMatch = finding['template-id']?.match(/(CVE-\d{4}-\d+)/i) || 
                          finding.info?.name?.match(/(CVE-\d{4}-\d+)/i);
          
          if (cveMatch) {
            const cveId = cveMatch[1].toUpperCase();
            results.set(cveId, {
              cveId,
              templateId: finding['template-id'] || '',
              verified: true,
              exploitable: finding.info.severity === 'critical' || finding.info.severity === 'high',
              details: finding
            });
          }
        }
      }
      
      // Mark CVEs that weren't found as not exploitable (but tested)
      for (const cveId of cveIds) {
        if (!results.has(cveId)) {
          results.set(cveId, {
            cveId,
            templateId: '',
            verified: false,
            exploitable: false
          });
        }
      }
      
    } catch (error) {
      log(`nuclei_cve=error target="${target}" error="${(error as Error).message}"`);
      // Return empty results map on error
    }
    
    return results;
  }

  /* Extract CVSS from severity string */
  extractCVSSFromSeverity(severity?: string): number | undefined {
    if (!severity) return undefined;
    const s = severity.toLowerCase();
    if (s.includes('critical')) return 9.5;
    if (s.includes('high')) return 7.5;
    if (s.includes('medium')) return 5.5;
    if (s.includes('low')) return 3.5;
    return undefined;
  }

  /* Map ecosystem names to GitHub format */
  mapEcosystemToGitHub(ecosystem: string): string {
    const mapping: Record<string, string> = {
      'npm': 'NPM',
      'pypi': 'PIP',
      'maven': 'MAVEN',
      'nuget': 'NUGET',
      'composer': 'COMPOSER',
      'rubygems': 'RUBYGEMS',
      'go': 'GO'
    };
    return mapping[ecosystem] || ecosystem.toUpperCase();
  }

  /* Assess license risk */
  assessLicenseRisk(license?: string): 'LOW' | 'MEDIUM' | 'HIGH' {
    if (!license) return 'LOW';
    
    const lowRisk = ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'BSD-2-Clause', 'ISC'];
    const highRisk = ['GPL-3.0', 'AGPL-3.0', 'SSPL-1.0'];
    
    if (lowRisk.some(l => license.includes(l))) return 'LOW';
    if (highRisk.some(l => license.includes(l))) return 'HIGH';
    
    return 'MEDIUM';
  }

  /* Filter low-value vulnerabilities */
  filterLowValue(vulns: VulnRecord[]): VulnRecord[] {
    const now = new Date();
    const cutoffDate = new Date(now.getFullYear() - CONFIG.DROP_VULN_AGE_YEARS, now.getMonth(), now.getDate());
    
    return vulns.filter(v => {
      // Always keep KEV vulnerabilities
      if (v.cisaKev) return true;
      
      // Keep high EPSS scores
      if ((v.epss ?? 0) >= 0.1) return true;
      
      // Filter by age
      if (v.publishedDate && v.publishedDate < cutoffDate) {
        return false;
      }
      
      // Filter by EPSS threshold  
      if ((v.epss ?? 0) < CONFIG.DROP_VULN_EPSS_CUT) {
        return false;
      }
      
      return true;
    });
  }

  /* Merge GHSA with CVE vulnerabilities */
  mergeGhsaWithCve(vulns: VulnRecord[]): VulnRecord[] {
    const cveMap = new Map<string, VulnRecord>();
    const ghsaMap = new Map<string, VulnRecord>();
    
    // Separate CVEs and GHSAs
    for (const v of vulns) {
      if (v.id.startsWith('CVE-')) {
        cveMap.set(v.id, v);
      } else if (v.id.startsWith('GHSA-')) {
        ghsaMap.set(v.id, v);
      }
    }
    
    // Future enhancement: merge by CVE reference in GHSA
    // For now, just return both
    return [...cveMap.values(), ...ghsaMap.values()];
  }

  /* Post-process vulnerabilities */
  postProcessVulnerabilities(
    vulns: VulnRecord[], 
    techName: string, 
    version?: string
  ): VulnRecord[] {
    return vulns.map(v => ({
      ...v,
      // Add any post-processing logic here
      summary: v.summary || `Vulnerability in ${techName}${version ? ` v${version}` : ''}`
    }));
  }

  /* Deduplicate vulnerabilities */
  dedupeVulns(vulns: VulnRecord[]): VulnRecord[] {
    const seen = new Set<string>();
    return vulns.filter(v => {
      if (seen.has(v.id)) return false;
      seen.add(v.id);
      return true;
    });
  }
}

export function createVulnerabilityAnalysis(config: VulnerabilityAnalysisConfig) {
  return new VulnerabilityAnalysis(config);
} 